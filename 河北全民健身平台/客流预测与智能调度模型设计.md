# 客流预测与智能调度模型设计方案

## 🎯 模型目标

基于项目现有的数据集、NLP分析、知识图谱等模块，构建一个**多因素客流预测模型**，实现：

1. **客流预测:** 预测未来时段的场馆客流量
2. **动态调整:** 根据预测结果调整开放时间
3. **智能分流:** 优化人员分布，避免拥挤

---

## 📊 可利用的现有资源

### 1. 数据资源
- ✅ **158个场馆数据** (fitness_facilities_data.json)
  - 场地面积、座位数、日客流量
  - 建成年份、设施类型、运营单位
  - 地理位置（省市区）
  
- ✅ **知识图谱** (fps_knowledge_graph.json)
  - 254个实体，634个关系
  - 设施-区域-时间-政策关系网络
  - 可提取关系特征

- ✅ **NLP分析能力** (text_analyzer.py)
  - 文本量化转换
  - 语义评分
  - 关键词提取

### 2. 模型资源
- ✅ **TransE嵌入模型** - 可用于特征提取
- ✅ **深度学习框架** - PyTorch
- ✅ **AHP评价模型** - 可用于权重计算
- ✅ **推荐系统** - 协同过滤算法

---

## 🏗️ 模型整体架构

```
┌─────────────────────────────────────────────────────┐
│              数据输入层                              │
├─────────────────────────────────────────────────────┤
│ 历史客流 | 时间特征 | 天气 | 事件 | 设施属性 | 知识图谱 │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│              特征工程层                              │
├─────────────────────────────────────────────────────┤
│ • 时间特征（周期性、趋势性）                         │
│ • 场馆特征（从知识图谱提取）                         │
│ • 外部因素（天气、节假日、赛事）                     │
│ • 知识图谱特征（关系嵌入、邻居特征）                 │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│            客流预测模型层                            │
├─────────────────────────────────────────────────────┤
│ LSTM时序 | XGBoost | Prophet | 知识图谱增强          │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│            模型融合层                                │
├─────────────────────────────────────────────────────┤
│ 加权融合 | 置信区间 | 异常检测                        │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│            决策优化层                                │
├─────────────────────────────────────────────────────┤
│ 开放时间调整 | 人员分流 | 资源配置                    │
└─────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────┐
│            输出与反馈层                              │
├─────────────────────────────────────────────────────┤
│ 预测结果 | 调度方案 | 可视化 | 效果评估               │
└─────────────────────────────────────────────────────┘
```

---

## 📝 详细设计方案

### 一、特征工程设计

#### 1.1 时间特征提取

**基础时间特征:**
```python
{
    'hour': 14,              # 小时 (0-23)
    'day_of_week': 2,        # 星期几 (0-6)
    'day_of_month': 30,      # 日期 (1-31)
    'month': 10,             # 月份 (1-12)
    'quarter': 4,            # 季度 (1-4)
    'is_weekend': 0,         # 是否周末
    'is_holiday': 0,         # 是否节假日
}
```

**周期性特征（正弦/余弦编码）:**
```python
{
    'hour_sin': sin(2π × hour / 24),
    'hour_cos': cos(2π × hour / 24),
    'day_sin': sin(2π × day_of_week / 7),
    'day_cos': cos(2π × day_of_week / 7),
    'month_sin': sin(2π × month / 12),
    'month_cos': cos(2π × month / 12),
}
```

**时间段特征:**
```python
{
    'time_period': 'morning',  # morning/afternoon/evening/night
    'is_peak_hour': 1,         # 是否高峰时段 (9-11, 18-20)
    'is_working_hour': 1,      # 是否工作时间 (9-18)
}
```

**滞后特征:**
```python
{
    'visitors_lag_1h': 245,    # 1小时前客流
    'visitors_lag_24h': 230,   # 24小时前客流
    'visitors_lag_7d': 250,    # 7天前同时段客流
    'visitors_avg_7d': 240,    # 过去7天平均客流
}
```

#### 1.2 场馆特征（从知识图谱提取）

**基础属性特征:**
```python
facility = kg.get_entity(facility_id)

features = {
    # 规模特征
    'site_area': 26800,           # 场地面积
    'building_area': 3500,        # 建筑面积
    'seats': 448,                 # 座位数
    'capacity_ratio': 0.65,       # 容量利用率
    
    # 类型特征（One-Hot编码）
    'type_stadium': 1,
    'type_gymnasium': 0,
    'type_fitness': 0,
    'type_swimming': 0,
    
    # 时间特征
    'build_year': 1991,
    'facility_age': 33,           # 场馆年龄
    
    # 位置特征
    'city_code': 1,               # 城市编码
    'is_provincial_capital': 0,   # 是否省会
}
```

**知识图谱关系特征:**
```python
# 从知识图谱提取
kg_features = {
    # 运动项目特征
    'sport_count': 5,                    # 提供运动项目数
    'has_basketball': 1,
    'has_swimming': 0,
    'has_fitness': 1,
    
    # 政策特征
    'has_subsidy': 1,                    # 是否有补助
    'policy_count': 2,                   # 受益政策数
    
    # 邻居特征
    'nearby_facility_count': 33,         # 同城设施数
    'nearby_avg_visitors': 280,          # 同城平均客流
    'nearby_total_area': 299300,         # 同城总面积
    
    # 区域特征
    'city_facility_density': 0.034,      # 城市设施密度
    'city_per_capita_area': 0.30,        # 人均场地面积
}
```

#### 1.3 外部因素特征

**天气特征:**
```python
{
    'weather_code': 0,        # 天气编码 (0晴 1阴 2雨 3雪)
    'temperature': 22,        # 温度
    'temperature_comfort': 1, # 舒适度 (15-25℃为1)
    'is_rainy': 0,           # 是否下雨
    'aqi': 85,               # 空气质量指数
    'aqi_level': 2,          # AQI等级 (1优 2良 3轻度污染...)
}
```

**事件特征:**
```python
{
    'has_event': 0,          # 是否有赛事活动
    'event_type': None,      # 活动类型
    'is_school_holiday': 0,  # 是否学校假期
    'days_to_holiday': 5,    # 距离下个假期天数
}
```

---

### 二、预测模型设计

#### 2.1 LSTM时序预测模型

**模型结构:**
```python
import torch
import torch.nn as nn

class LSTMTrafficPredictor(nn.Module):
    def __init__(self, input_size=50, hidden_size=128, num_layers=2):
        super().__init__()
        
        # LSTM层
        self.lstm = nn.LSTM(
            input_size=input_size,
            hidden_size=hidden_size,
            num_layers=num_layers,
            batch_first=True,
            dropout=0.2
        )
        
        # 注意力机制
        self.attention = nn.Linear(hidden_size, 1)
        
        # 全连接层
        self.fc = nn.Sequential(
            nn.Linear(hidden_size, 64),
            nn.ReLU(),
            nn.Dropout(0.2),
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Linear(32, 1)
        )
    
    def forward(self, x):
        # x: (batch, seq_len, input_size)
        lstm_out, _ = self.lstm(x)
        
        # 注意力权重
        attention_weights = torch.softmax(
            self.attention(lstm_out), dim=1
        )
        
        # 加权求和
        context = torch.sum(attention_weights * lstm_out, dim=1)
        
        # 预测
        output = self.fc(context)
        return output
```

**训练策略:**
- 序列长度: 24小时（预测下1小时）
- 批次大小: 64
- 学习率: 0.001
- 优化器: Adam
- 损失函数: MSE + MAE

**适用场景:**
- 捕捉时间序列的长期依赖
- 处理周期性模式
- 适合连续预测

#### 2.2 XGBoost回归模型

**模型配置:**
```python
import xgboost as xgb

model = xgb.XGBRegressor(
    n_estimators=1000,
    learning_rate=0.05,
    max_depth=6,
    min_child_weight=3,
    subsample=0.8,
    colsample_bytree=0.8,
    gamma=0.1,
    reg_alpha=0.1,
    reg_lambda=1.0,
    objective='reg:squarederror'
)
```

**特征重要性分析:**
```python
# 获取特征重要性
importance = model.feature_importances_

# 可视化
top_features = [
    'visitors_lag_24h',      # 重要性: 0.25
    'hour_of_day',           # 重要性: 0.18
    'day_of_week',           # 重要性: 0.15
    'temperature',           # 重要性: 0.12
    'nearby_avg_visitors',   # 重要性: 0.10
    ...
]
```

**适用场景:**
- 处理非线性关系
- 特征交互建模
- 鲁棒性强

#### 2.3 Prophet趋势预测

**模型配置:**
```python
from prophet import Prophet

model = Prophet(
    yearly_seasonality=True,
    weekly_seasonality=True,
    daily_seasonality=True,
    seasonality_mode='multiplicative',
    changepoint_prior_scale=0.05
)

# 添加自定义季节性
model.add_seasonality(
    name='hourly',
    period=24,
    fourier_order=8
)

# 添加节假日效应
model.add_country_holidays(country_name='CN')
```

**适用场景:**
- 长期趋势预测
- 自动处理季节性
- 节假日效应建模

#### 2.4 知识图谱增强模型

**核心思想:** 利用知识图谱中的关系信息增强预测

```python
class KGEnhancedPredictor:
    def __init__(self, base_model, kg_query):
        self.base_model = base_model
        self.kg = kg_query
    
    def predict(self, facility_id, timestamp, features):
        # 1. 基础预测
        base_pred = self.base_model.predict(features)
        
        # 2. 从知识图谱提取邻居信息
        city = self.kg.get_facility_city(facility_id)
        neighbors = self.kg.query_city_facilities(city)
        
        # 3. 计算邻居影响
        neighbor_preds = []
        for neighbor in neighbors:
            if neighbor['id'] != facility_id:
                # 获取邻居的预测值
                neighbor_pred = self.get_neighbor_prediction(
                    neighbor['id'], timestamp
                )
                # 根据距离和相似度加权
                weight = self.calculate_similarity(
                    facility_id, neighbor['id']
                )
                neighbor_preds.append(neighbor_pred * weight)
        
        # 4. 融合预测
        if neighbor_preds:
            neighbor_avg = np.mean(neighbor_preds)
            # 自适应权重
            alpha = 0.7  # 基础模型权重
            beta = 0.3   # 邻居影响权重
            final_pred = alpha * base_pred + beta * neighbor_avg
        else:
            final_pred = base_pred
        
        return final_pred
    
    def calculate_similarity(self, fac1, fac2):
        """计算设施相似度"""
        # 基于知识图谱的相似度
        # 1. 共同运动项目
        sports1 = set(self.kg.query_facility_sports(fac1))
        sports2 = set(self.kg.query_facility_sports(fac2))
        sport_sim = len(sports1 & sports2) / len(sports1 | sports2)
        
        # 2. 设施类型相似度
        type1 = self.kg.get_entity(fac1)['type']
        type2 = self.kg.get_entity(fac2)['type']
        type_sim = 1.0 if type1 == type2 else 0.5
        
        # 3. 规模相似度
        area1 = self.kg.get_entity(fac1)['site_area']
        area2 = self.kg.get_entity(fac2)['site_area']
        area_sim = 1 - abs(area1 - area2) / max(area1, area2)
        
        # 加权平均
        similarity = 0.4 * sport_sim + 0.3 * type_sim + 0.3 * area_sim
        return similarity
```

---

### 三、模型融合策略

#### 3.1 加权融合

```python
class EnsemblePredictor:
    def __init__(self):
        self.models = {
            'lstm': LSTMTrafficPredictor(),
            'xgboost': XGBoostTrafficPredictor(),
            'prophet': ProphetTrafficPredictor(),
            'kg_enhanced': KGEnhancedPredictor()
        }
        
        # 动态权重（根据验证集表现）
        self.weights = {
            'lstm': 0.35,
            'xgboost': 0.30,
            'prophet': 0.20,
            'kg_enhanced': 0.15
        }
    
    def predict(self, facility_id, timestamp, features):
        predictions = {}
        
        # 各模型预测
        for name, model in self.models.items():
            predictions[name] = model.predict(
                facility_id, timestamp, features
            )
        
        # 加权融合
        final_pred = sum(
            predictions[name] * self.weights[name]
            for name in predictions
        )
        
        # 计算置信区间
        std = np.std(list(predictions.values()))
        confidence_interval = (
            max(0, final_pred - 1.96 * std),
            final_pred + 1.96 * std
        )
        
        return {
            'prediction': int(final_pred),
            'confidence_interval': confidence_interval,
            'individual_predictions': predictions
        }
```

#### 3.2 异常检测

```python
class AnomalyDetector:
    def detect(self, prediction, historical_data):
        """检测预测异常"""
        # 1. 统计异常
        mean = np.mean(historical_data)
        std = np.std(historical_data)
        z_score = (prediction - mean) / std
        
        if abs(z_score) > 3:
            # 异常修正
            corrected = mean + np.sign(z_score) * 2 * std
            return True, corrected
        
        # 2. 容量约束
        max_capacity = self.get_max_capacity(facility_id)
        if prediction > max_capacity:
            return True, max_capacity
        
        return False, prediction
```

---

### 四、智能调度决策

#### 4.1 开放时间动态调整

**决策规则:**
```python
class OpeningTimeOptimizer:
    def optimize(self, facility_id, predictions):
        """优化开放时间"""
        schedule = []
        
        for hour in range(24):
            pred_visitors = predictions[hour]
            
            # 决策规则
            if pred_visitors < 50:
                status = 'closed'
                staff = 0
            elif pred_visitors < 150:
                status = 'limited_open'  # 部分开放
                staff = 2
            elif pred_visitors < 300:
                status = 'normal_open'
                staff = 4
            else:
                status = 'full_open'
                staff = 6
            
            schedule.append({
                'hour': hour,
                'predicted_visitors': pred_visitors,
                'status': status,
                'staff_count': staff
            })
        
        return schedule
```

**调整策略:**
```python
# 示例输出
{
    '06:00-09:00': {
        'status': 'limited_open',
        'areas': ['室外场地'],
        'staff': 2
    },
    '09:00-12:00': {
        'status': 'full_open',
        'areas': ['全部场地'],
        'staff': 6
    },
    '12:00-14:00': {
        'status': 'normal_open',
        'areas': ['室内场馆'],
        'staff': 4
    },
    ...
}
```

#### 4.2 人员分流策略

**分流算法:**
```python
class TrafficDistributor:
    def distribute(self, city_facilities, predictions):
        """智能分流"""
        recommendations = []
        
        for facility in city_facilities:
            fac_id = facility['id']
            pred = predictions[fac_id]
            capacity = facility['capacity']
            
            # 计算负载率
            load_rate = pred / capacity
            
            # 分流建议
            if load_rate > 0.9:
                # 推荐到邻近设施
                alternatives = self.find_alternatives(
                    fac_id, city_facilities
                )
                recommendations.append({
                    'facility_id': fac_id,
                    'status': 'crowded',
                    'load_rate': load_rate,
                    'alternatives': alternatives
                })
            elif load_rate < 0.3:
                recommendations.append({
                    'facility_id': fac_id,
                    'status': 'available',
                    'load_rate': load_rate
                })
        
        return recommendations
    
    def find_alternatives(self, facility_id, all_facilities):
        """查找替代场馆"""
        # 从知识图谱获取相似设施
        target = self.kg.get_entity(facility_id)
        target_sports = self.kg.query_facility_sports(facility_id)
        
        alternatives = []
        for fac in all_facilities:
            if fac['id'] == facility_id:
                continue
            
            # 检查运动项目匹配
            fac_sports = self.kg.query_facility_sports(fac['id'])
            if set(target_sports) & set(fac_sports):
                # 计算距离（简化为同城）
                if fac['city'] == target['city']:
                    alternatives.append({
                        'facility_id': fac['id'],
                        'name': fac['name'],
                        'distance': 'nearby',
                        'predicted_load': fac['predicted_load']
                    })
        
        # 按负载率排序
        alternatives.sort(key=lambda x: x['predicted_load'])
        return alternatives[:3]
```

---

### 五、实施方案

#### 5.1 数据准备

**步骤1: 补充数据**
```python
# 需要补充的数据
required_data = {
    'hourly_traffic': '小时级客流数据',
    'weather': '天气数据（可调用API）',
    'events': '赛事活动数据',
    'holidays': '节假日数据'
}
```

**步骤2: 数据生成（模拟）**
```python
# 基于现有日客流数据生成小时数据
def generate_hourly_data(daily_visitors):
    """生成小时分布"""
    # 典型分布模式
    hourly_pattern = {
        6: 0.02, 7: 0.04, 8: 0.06, 9: 0.08,
        10: 0.07, 11: 0.06, 12: 0.05, 13: 0.04,
        14: 0.05, 15: 0.06, 16: 0.08, 17: 0.10,
        18: 0.12, 19: 0.10, 20: 0.05, 21: 0.02
    }
    
    hourly_data = {}
    for hour, ratio in hourly_pattern.items():
        hourly_data[hour] = int(daily_visitors * ratio)
    
    return hourly_data
```

#### 5.2 模型训练流程

```python
# 1. 加载数据
facilities_data = load_json('fitness_facilities_data.json')
kg_data = load_json('fps_knowledge_graph.json')

# 2. 特征工程
feature_extractor = FeatureExtractor(kg_data)
X, y = feature_extractor.prepare_training_data(facilities_data)

# 3. 训练各模型
models = {
    'lstm': train_lstm_model(X, y),
    'xgboost': train_xgboost_model(X, y),
    'prophet': train_prophet_model(X, y),
    'kg_enhanced': train_kg_model(X, y, kg_data)
}

# 4. 模型融合
ensemble = EnsemblePredictor(models)

# 5. 评估
metrics = evaluate_model(ensemble, X_test, y_test)
```

#### 5.3 部署方案

**API接口设计:**
```python
# FastAPI端点
@app.post("/api/v1/traffic/predict")
async def predict_traffic(request: PredictRequest):
    """预测客流"""
    prediction = ensemble.predict(
        facility_id=request.facility_id,
        timestamp=request.timestamp,
        features=request.features
    )
    return prediction

@app.post("/api/v1/schedule/optimize")
async def optimize_schedule(facility_id: str, date: str):
    """优化开放时间"""
    # 预测24小时客流
    predictions = []
    for hour in range(24):
        pred = predict_traffic(facility_id, f"{date} {hour}:00")
        predictions.append(pred)
    
    # 生成调度方案
    schedule = optimizer.optimize(facility_id, predictions)
    return schedule

@app.post("/api/v1/traffic/distribute")
async def distribute_traffic(city: str, timestamp: str):
    """智能分流"""
    facilities = kg.query_city_facilities(city)
    predictions = predict_all_facilities(facilities, timestamp)
    recommendations = distributor.distribute(facilities, predictions)
    return recommendations
```

---

### 六、评估指标

#### 6.1 预测准确性
- **MAE** (平均绝对误差): < 20人
- **RMSE** (均方根误差): < 30人
- **MAPE** (平均绝对百分比误差): < 15%
- **R²** (决定系数): > 0.85

#### 6.2 业务指标
- **场馆利用率提升**: > 15%
- **用户等待时间减少**: > 20%
- **运营成本降低**: > 10%
- **用户满意度提升**: > 25%

---

### 七、可视化展示

#### 7.1 预测结果可视化
- 时间序列图（实际 vs 预测）
- 置信区间展示
- 各模型对比
- 特征重要性图

#### 7.2 调度方案可视化
- 24小时开放时间表
- 人员配置甘特图
- 负载率热力图
- 分流路线图

---

## 🎯 总结

### 核心优势
1. **多模型融合**: LSTM+XGBoost+Prophet+知识图谱
2. **知识图谱增强**: 利用设施关系网络提升预测
3. **完整决策链**: 预测→调度→分流
4. **可解释性强**: 特征重要性+模型对比

### 创新点
1. 首次将知识图谱应用于客流预测
2. 基于LKDF框架的多维度特征建模
3. 动态权重的模型融合策略
4. 智能分流的图算法应用

### 实施建议
1. **短期**: 基于现有数据训练基础模型
2. **中期**: 补充实时数据，优化模型
3. **长期**: 接入IoT设备，实现闭环

---

**文档版本:** 1.0  
**更新时间:** 2025-10-30  
**设计者:** AI Assistant
